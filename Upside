local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Spieler und Charakter Referenzen
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Animation IDs und Namen
local animationData = {
    {id = "rbxassetid://11137338685", name = "vip m"},
    {id = "rbxassetid://137445502103066", name = "vip 03"},
    {id = "rbxassetid://17619014027", name = "punch  5"},
    {id = "rbxassetid://13027233338", name = "handstand"},
    {id = "rbxassetid://124385779438289", name = "ghostly"},
    {id = "rbxassetid://116818881329505", name = "log"},
    {id = "rbxassetid://134763058840745", name = "oof"},
    {id = "rbxassetid://14852161489", name = "die"} -- << NEU: "die" Animation mit korrekter ID
}

-- Animations-Objekte
local animations = {}
-- currentAnimation Variable war deklariert aber nie benutzt, kann entfernt werden, wenn nicht geplant.
-- local currentAnimation = nil 

-- GUI erstellen
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AnimationsGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = player:WaitForChild("PlayerGui") -- Sicherstellen, dass PlayerGui geladen ist

-- Anpassung der Anordnung
local BUTTON_HEIGHT = 30
local BUTTON_SPACING = 5
-- local TOTAL_ANIM_BUTTONS = #animationData -- Nicht unbedingt notwendig, da ipairs über animationData iteriert
local BUTTONS_PER_ROW = {4, 4} -- Erste Reihe 4, zweite Reihe 4 (für 8 Buttons)
local ROWS_NEEDED = #BUTTONS_PER_ROW -- Dynamischer basierend auf der Definition von BUTTONS_PER_ROW

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
-- Anpassung der Größe basierend auf der neuen Anordnung
local frameHeight = 30 + (ROWS_NEEDED * (BUTTON_HEIGHT + BUTTON_SPACING)) + 70 -- Platz für Titel und spezielle Buttons
MainFrame.Size = UDim2.new(0, 280, 0, frameHeight)
MainFrame.Position = UDim2.new(0.85, 0, 0.5, -frameHeight/2)
MainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
MainFrame.BorderSizePixel = 2
MainFrame.BorderColor3 = Color3.fromRGB(60, 60, 60)
MainFrame.Parent = ScreenGui

-- Titel
local TitleLabel = Instance.new("TextLabel")
TitleLabel.Name = "TitleLabel"
TitleLabel.Size = UDim2.new(1, 0, 0, 30)
TitleLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
TitleLabel.BorderSizePixel = 0
TitleLabel.Text = "Animations"
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.TextSize = 18
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.Parent = MainFrame

-- Drag-Funktion für die GUI
local isDragging = false
local dragStart = nil
local startPos = nil

TitleLabel.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isDragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function() -- Verbindung trennen, wenn die Maus losgelassen wird, während sie sich außerhalb befindet
            if input.UserInputState == Enum.UserInputState.End then
                isDragging = false
            end
        end)
    end
end)

TitleLabel.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isDragging = false
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if isDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

-- Animations-Container
local AnimationsContainer = Instance.new("Frame")
AnimationsContainer.Name = "AnimationsContainer"
-- Die Höhe des Containers wird dynamisch durch die Anzahl der Reihen und Button-Höhen bestimmt
local animationsContainerHeight = ROWS_NEEDED * BUTTON_HEIGHT + (ROWS_NEEDED - 1) * BUTTON_SPACING
if ROWS_NEEDED == 0 then animationsContainerHeight = 0 end -- Fall für keine Animationen

AnimationsContainer.Size = UDim2.new(1, -20, 0, animationsContainerHeight)
AnimationsContainer.Position = UDim2.new(0, 10, 0, 40) -- Unter dem Titel
AnimationsContainer.BackgroundTransparency = 1
AnimationsContainer.BorderSizePixel = 0
AnimationsContainer.Parent = MainFrame

-- Animations-Buttons erstellen
local currentButtonIndex = 0
for rowIndex = 1, ROWS_NEEDED do
    local buttonsInThisRow = BUTTONS_PER_ROW[rowIndex]
    if not buttonsInThisRow then break end -- Falls weniger Reihen definiert als benötigt

    for colIndex = 1, buttonsInThisRow do
        currentButtonIndex = currentButtonIndex + 1
        if currentButtonIndex > #animationData then break end

        local animInfo = animationData[currentButtonIndex]
        local i = currentButtonIndex -- Für den Zugriff in der Klickfunktion

        -- Animation laden
        local animation = Instance.new("Animation")
        animation.AnimationId = animInfo.id
        animations[i] = {
            id = animInfo.id, -- ID hier speichern für spätere Vergleiche beim Neuladen
            animationInstance = animation, -- Umbenannt von 'animation' zu 'animationInstance' für Klarheit
            track = nil,
            playing = false
        }

        -- Button erstellen
        local button = Instance.new("TextButton")
        button.Name = animInfo.name .. "Button"

        local buttonWidthScale = (1 / buttonsInThisRow)
        local xPosScale = (colIndex - 1) * buttonWidthScale
        local xPosOffset = (colIndex -1) * BUTTON_SPACING
        if colIndex == 1 then xPosOffset = 0 end -- Kein linker Abstand für den ersten Button

        local yPosScale = 0 -- Buttons sind relativ zum AnimationsContainer
        local yPosOffset = (rowIndex - 1) * (BUTTON_HEIGHT + BUTTON_SPACING)

        -- Anpassung der Breite, um Spacing zu berücksichtigen
        local totalSpacingInRow = (buttonsInThisRow - 1) * BUTTON_SPACING
        local effectiveButtonWidth = (AnimationsContainer.AbsoluteSize.X - totalSpacingInRow) / buttonsInThisRow
        
        button.Size = UDim2.new(0, effectiveButtonWidth, 0, BUTTON_HEIGHT)
        button.Position = UDim2.new(0, ((colIndex - 1) * effectiveButtonWidth) + ((colIndex - 1) * BUTTON_SPACING) , 0, yPosOffset)


        button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        button.BorderColor3 = Color3.fromRGB(40, 40, 40)
        button.Text = animInfo.name
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextSize = 14
        button.Font = Enum.Font.GothamSemibold
        button.Parent = AnimationsContainer
        
        button.MouseButton1Click:Connect(function()
            if animations[i].playing then
                if animations[i].track then
                    animations[i].track:Stop()
                end
                animations[i].playing = false
                button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            else
                for j, otherAnimData in ipairs(animations) do
                    if otherAnimData.playing and otherAnimData.track then
                        otherAnimData.track:Stop()
                        otherAnimData.playing = false
                        local otherButton = AnimationsContainer:FindFirstChild(animationData[j].name .. "Button")
                        if otherButton then
                            otherButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                        end
                    end
                end
                
                if not humanoid or not humanoid.Parent then -- Sicherstellen, dass der Humanoid noch existiert
                    warn("Humanoid nicht verfügbar. Animation kann nicht abgespielt werden.")
                    character = player.Character or player.CharacterAdded:Wait() -- Versuche Charakter und Humanoid neu zu bekommen
                    humanoid = character:WaitForChild("Humanoid")
                    if not humanoid then return end -- Immer noch nicht da, abbrechen
                end

                -- Track nur neu laden, wenn nötig (z.B. nach Charakterwechsel oder wenn nicht vorhanden)
                if not animations[i].track or animations[i].track.Animation ~= animations[i].animationInstance then
                    animations[i].track = humanoid:LoadAnimation(animations[i].animationInstance)
                end

                if animations[i].track then
                    animations[i].track:Play()
                    animations[i].playing = true
                    button.BackgroundColor3 = Color3.fromRGB(40, 180, 40)
                else
                     warn("Animationstrack konnte nicht geladen/gefunden werden für: " .. animInfo.name)
                end
            end
        end)
    end
    if currentButtonIndex >= #animationData then break end
end


-- Spezielle Buttons-Container
local SpecialButtonsContainer = Instance.new("Frame")
SpecialButtonsContainer.Name = "SpecialButtonsContainer"
SpecialButtonsContainer.Size = UDim2.new(1, -20, 0, 40)
SpecialButtonsContainer.Position = UDim2.new(0, 10, 0, animationsContainerHeight + 40 + BUTTON_SPACING) -- Positioniert unter dem AnimationsContainer
SpecialButtonsContainer.BackgroundTransparency = 1
SpecialButtonsContainer.Parent = MainFrame

-- Spezielle Buttons erstellen
local specialButtons = {
    {name = "Mini", event = "MiniEvent", color = Color3.fromRGB(255, 100, 100)},
    {name = "Huge", event = "HugeEvent", color = Color3.fromRGB(100, 100, 255)},
    {name = "Wide", event = "WideEvent", color = Color3.fromRGB(255, 200, 100)}
}

local specialButtonWidthScale = 1 / #specialButtons
local specialButtonSpacing = 5 -- Pixel-Abstand zwischen speziellen Buttons

for i, btnData in ipairs(specialButtons) do
    local button = Instance.new("TextButton")
    button.Name = btnData.name .. "Button"
    
    -- Berechnung für gleichmäßige Verteilung mit Abstand
    local effectiveWidth = (SpecialButtonsContainer.AbsoluteSize.X - ( (#specialButtons - 1) * specialButtonSpacing)) / #specialButtons
    local xPos = (i-1) * (effectiveWidth + specialButtonSpacing)

    button.Size = UDim2.new(0, effectiveWidth, 1, 0)
    button.Position = UDim2.new(0, xPos, 0, 0)
    
    button.BackgroundColor3 = btnData.color
    button.BorderColor3 = Color3.fromRGB(40, 40, 40)
    button.Text = btnData.name
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 16
    button.Font = Enum.Font.GothamBold
    button.Parent = SpecialButtonsContainer
    
    button.MouseButton1Click:Connect(function()
        local event = ReplicatedStorage:FindFirstChild(btnData.event)
        if event and event:IsA("RemoteEvent") then
            event:FireServer()
            
            local originalColor = button.BackgroundColor3
            button.BackgroundColor3 = Color3.fromRGB(255, 255, 255) -- Visuelles Feedback
            task.delay(0.2, function()
                if button and button.Parent then -- Sicherstellen, dass der Button noch existiert
                    button.BackgroundColor3 = originalColor
                end
            end)
        else
            warn("RemoteEvent " .. btnData.event .. " nicht gefunden!")
        end
    end)
end

-- Character-Wechsel-Handler
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    
    for i, animEntry in ipairs(animations) do
        if animEntry.playing and animEntry.track then
            animEntry.track:Stop()
        end
        animEntry.playing = false
        animEntry.track = nil -- Wichtig: Track zurücksetzen, damit er beim nächsten Mal mit dem neuen Humanoid geladen wird
        
        local button = AnimationsContainer:FindFirstChild(animationData[i].name .. "Button")
        if button then
            button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end
    end
end)

-- Minimieren-Button
local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Size = UDim2.new(0, 20, 0, 20)
MinimizeButton.Position = UDim2.new(1, -50, 0, 5)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
MinimizeButton.BorderColor3 = Color3.fromRGB(40, 40, 40)
MinimizeButton.Text = "-"
MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.TextSize = 16
MinimizeButton.Font = Enum.Font.GothamBold
MinimizeButton.Parent = MainFrame

-- Close-Button
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 20, 0, 20)
CloseButton.Position = UDim2.new(1, -25, 0, 5)
CloseButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
CloseButton.BorderColor3 = Color3.fromRGB(40, 40, 40)
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 14
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Parent = MainFrame

CloseButton.MouseButton1Click:Connect(function()
    for _, animEntry in ipairs(animations) do
        if animEntry.playing and animEntry.track then
            animEntry.track:Stop()
        end
    end
    ScreenGui:Destroy()
end)

local isMinimized = false
MinimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    if isMinimized then
        AnimationsContainer.Visible = false
        SpecialButtonsContainer.Visible = false
        MainFrame.Size = UDim2.new(0, MainFrame.AbsoluteSize.X, 0, 30) -- Breite beibehalten, Höhe anpassen
        MinimizeButton.Text = "+"
    else
        AnimationsContainer.Visible = true
        SpecialButtonsContainer.Visible = true
        MainFrame.Size = UDim2.new(0, MainFrame.AbsoluteSize.X, 0, frameHeight) -- Breite beibehalten, Höhe wiederherstellen
        MinimizeButton.Text = "-"
    end
end)

print("Animation GUI geladen!")
